- [トランザクションのライフサイクル](#トランザクションのライフサイクル)
  - [EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する](#eoaはトランザクションmessage-call-or-contract-creationを各ノードに伝搬する)
  - [各ノードは、受け取ったトランザクションを独立に検証する](#各ノードは受け取ったトランザクションを独立に検証する)
  - [各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する](#各ノードは問題が無いトランザクションのみを溜めかつ他のノードに伝搬する)
  - [バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる](#バリデータノードたちは確率的にブロックの提案-or-投票ノードに選ばれる)
    - [PoWからPoSへ](#powからposへ)
    - [Stakingとバリデータ、バリデータノード](#stakingとバリデータバリデータノード)
    - [ランダムな選択](#ランダムな選択)
    - [提案ノードの選択](#提案ノードの選択)
    - [投票ノードの選択](#投票ノードの選択)
  - [投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する](#投票ノードたちは正統と考えるチェーンの先端にあるブロックを宣言する)
  - [提案ノードは、任意のトランザクションおよび宣言をブロックに格納する](#提案ノードは任意のトランザクションおよび宣言をブロックに格納する)
    - [Ethereumブロックのデータ構造](#ethereumブロックのデータ構造)
    - [Block Gas Limitについて](#block-gas-limitについて)
    - [baseFeePerGasの決定ルールについて](#basefeepergasの決定ルールについて)
    - [State Root, Receipts Rootについて](#state-root-receipts-rootについて)
  - [提案ノードは、ブロック内のトランザクションを実行する](#提案ノードはブロック内のトランザクションを実行する)
  - [提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ](#提案ノードはブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ)
  - [提案ノードは、完成したブロックを各ノードに伝搬する](#提案ノードは完成したブロックを各ノードに伝搬する)
  - [各ノードは、受け取ったブロックに問題が無いかを独立に検証する](#各ノードは受け取ったブロックに問題が無いかを独立に検証する)
  - [各ノードは、問題が無いブロックのみを自身のチェーンに反映する](#各ノードは問題が無いブロックのみを自身のチェーンに反映する)
  - [バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする](#バリデータノードたちは最も重いチェーンを正しい状態遷移の記録とする)
- [まとめ](#まとめ)


# トランザクションのライフサイクル
 
ここまでEthereumの構成要素を確認してきましたが、これらはどのように連動しているのでしょうか。
あるトランザクションが作成されてから実行され、ブロックチェーンに格納されるまでのライフサイクルを軸に詳細を確認してましょう。

Introductionで示したとおり、トランザクションのライフサイクルは大きく以下のような流れになっている

```
EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する
各ノードは、受け取ったトランザクションを独立に検証する
各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する
バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる
投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する
提案ノードは、任意のトランザクションおよび宣言をブロックに格納する
提案ノードは、ブロック内のトランザクションを実行する
提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ
提案ノードは、完成したブロックを各ノードに伝搬する
各ノードは、受け取ったブロックに問題が無いかを独立に検証する
各ノードは、問題が無いブロックのみを自身のチェーンに反映する
バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする
```

## [EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する](../P02_ethereum/3_transactionlife.md#EOAは、トランザクション(message-call-or-contract-creation)を各ノードに伝搬する)
以前のEthereumと同様である

## [各ノードは、受け取ったトランザクションを独立に検証する](../P02_ethereum/3_transactionlife.md#各ノードは、受け取ったトランザクションを独立に検証する)
以前のEthereumと同様である

## [各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する](../P02_ethereum/3_transactionlife.md#各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する)
以前のEthereumと同様である


## バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる

### PoWからPoSへ

詳しくは後述しますが、スケーラビリティ問題に対応するため、Ethereumは2022年8月にブロック作成要件をPoWからPoSへ移行しました.これによって、Bitcoinと仕様が大きく異なり始めます。

EthereumのPoSは、おおまかには次の仕組みでブロック作成者を決定します。

まず、full (またはarchive) nodeは、自身が管理するEOAからdeposit contractと呼ばれるコントラクトアカウントに32ETH以上を預ける (stakeする) ことでバリデータノードになれます。

将来のブロック作成者はバリデータノードの中から定期的に選択されますが、このとき以前のブロックに投票するバリデータノードたちも選択されます。ここでの選択は確率的に行われますが、選択される確率は各バリデータノードのstake量で重み付けされています。

この仕組みによって、PoWのように、各ノードが`採掘作業を重複して行う必要`がなくなります。そのためネットワークを維持するためのエネルギー消費が抑えられて効率的でエコになります。

しかし、"PoW vs PoS" はブロックチェーンにおいて最も伝統的な論点の1つであり、現在も様々な観点 (e.g., どちらが公正なのか？ どちらが効率的なのか？ どちらが分散的なのか？ どちらが環境に優しいのか？) で研究・分析が引き続き行われています。


### Stakingとバリデータ、バリデータノード 

EOAは32ETHをdeposit contractに預けることで、アカウント用の鍵とは別にValidator Signing KeyとWithdrawal Keyの2種類 (それぞれ秘密・公開鍵から成る) が得られます。

この様にValidator用の鍵を別途用意するのは、次の3つの理由によります。
1. セキュリティ上、アカウント用の鍵とバリデータ用の鍵は分けておきたい
2. SaaS(Staking as a Service)などを運用する余地を残しておきたい(詳細後述)
3. 楕円曲線暗号よりも署名の集約に適した暗号形式を用いたい

2種類の鍵は、トランザクションを作成することは出来ません。一つのEOAが複数のバリデータ用の鍵を持つことも出来ます。この32ETH毎に作られる2種類の鍵を持つ単位を、ここでは便宜上「バリデータ」と呼び「バリデータノード」とは区別するものとします。

> 2024年1月において、バリデータの数は約900,000個

バリデータ用の鍵を別途作ることにより、次のような運用が可能になります。

1. 自身が管理するバリデータ鍵をノードに渡すことで、Stakingを委任出来る。この場合、自身でノードを建てずともStakingが行える (Staking as a Service; SaaS)
2. また、そもそもバリデータ自体を自分で用意せずにStakingを行うことも出来る。つまり、Bitcoinにおけるマイニングプールのように少額のETHを集約して共用のバリデータ (Staking Pool)を運用することが可能です。

Solo Staking, SaaS, Staking Poolの3つの運用方法について、それぞれの特徴を以下にまとめます。
  
|  | 自身で用意するもの | 自身で作成するもの | 自身で管理するもの | トラストへの依存 |
| ---- | ---- | ---- | ---- | ---- |
| Solo Staking | full (or archive) node, 32ETH以上のETH | バリデーターノード, バリデーター | バリデーターノード, バリデーター | 低
| Staking as a Service (SaaS) | 32ETH以上のETH | バリデーター |  | 中
| Staking Pool | 任意量のETH | |  | 高
  

### ランダムな選択

Ethereumのブロックチェーンは、12秒をslot、32slot (6.4分) をepochと呼び、slot, epoch単位でブロックの提案や合意形成、報酬などを管理しています。Bitcoinではslotは (block intervalとして) 約10分になるように設計されていました。Bitcoinにおけるdifficultyの概念はEthereumには存在しません。

### 提案ノードの選択

提案ノードの選択は、1つ前のepochのslot 0 時点で一気に行われます。このとき、バリデータのstake量が多いほど選ばれる確率が高くなりますが、32ETHを超えるともう上がらないようになっています。また、詳細は後述しますが、stakeされたETHはペナルティとして一部が没収される可能性があります。したがってバリデータのstake量は (事後的に) 32ETH未満になりえます。

多くのバリデータを管理するノードほど、ブロック提案の権利を得る確率が高まるため、ノードの視点からすれば32ETHが宝くじ1枚のような扱いになっています。


### 投票ノードの選択

提案ノードと同様に、epochの各slotに対応するブロック投票者も、1つ前のepochのslot 0 時点で一気に選択されます。1slotにnバリデータ (not バリデータノード) ずつ割り当てられます。このバリデータたちはcommiteeという単位でまとめられ、合意形成に必要な投票を担います。なぜなら、投票の集約はcommitee単位で並列化して行った方が効率的だからです。1slotあたりのcommitee数と1commiteeあたりのバリデータ数は、ネットワーク上の総バリデータ数に応じてepoch毎に変動します。最近のnは15,000~20,000あたりです。したがって1epochの間に全バリデータに投票機会があります。

同様に、多くのバリデータを管理するノードほど、ブロック投票の権利を得る確率が高まるため、ノードの視点からすれば32ETHが宝くじ1枚のような扱いになっています。

## 投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する

Commiteeに選ばれたバリデータ (実際にはそれを管理するノード) は、ブロックチェーンの構造に関する投票 (attestation) を行うことが出来ます。

- 割り当てられたslotのブロックは未作成なので、それ以前の内容に関して投票を行います
- ただし投票自体は、32slot先までの間ならば一応行えます 
- 具体的には次の二つを宣言します
  1. 現在どのブロックが先端にあるか？
  2. 現在どのブロックが最新のepochの最初のブロックか？の2つを宣言します

宣言の中身は以下のとおり

| 名称 | 役割 |
| ---- | ---- |
| slot | 割り当てられたslotの番号
| index | そのslotにおける何番目のcommiteeに所属しているか
| beacon_block_root | 先端だと思うブロックのヘッダーのハッシュ
| source | 最新のjustified (後述) されたと思うブロック
| target | 現在のepochで最初にあると思うブロック

上記がcommiteeごとに集約され同じslotのブロック提案者に渡されます。このとき、slot, indexが同じでも、残り3つの情報が異なる場合は別のグループに集約されます。投票が遅れた場合には、投票時のslotのブロック提案者に渡されます。

この集約の際には Validator Signing Key が使用されます。EOAの鍵 (楕円曲線暗号)とは異なる形式 (BLS署名) のため、署名の集約を行うことが出来ます。

## 提案ノードは、任意のトランザクションおよび宣言をブロックに格納する

### Ethereumブロックのデータ構造


### [Block Gas Limitについて](../P02_ethereum/3_transactionlife.md#block-gas-limitについて)
以前のEthereumと同様である
### [baseFeePerGasの決定ルールについて](../P02_ethereum/3_transactionlife.md#baseFeePerGasの決定ルールについて)
以前のEthereumと同様である
### [State Root, Receipts Rootについて](../P02_ethereum/3_transactionlife.md#state-root,-receipts-rootについて)
以前のEthereumと同様である

## [提案ノードは、ブロック内のトランザクションを実行する](../P02_ethereum/3_transactionlife.md#提案ノードは、ブロック内のトランザクションを実行する)
以前のEthereumと同様である (提案ノードとマイナーノードという違いはある)


## [提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ](../P02_ethereum/3_transactionlife.md#提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ)


## [提案ノードは、完成したブロックを各ノードに伝搬する](../P02_ethereum/3_transactionlife.md#マイナーノードは、完成したブロックを各ノードに伝搬する)

## [各ノードは、受け取ったブロックに問題が無いかを独立に検証する](../P02_ethereum/3_transactionlife.md#各ノードは、受け取ったブロックに問題が無いかを独立に検証する)


## [各ノードは、問題が無いブロックのみを自身のチェーンに反映する](../P02_ethereum/3_transactionlife.md#各ノードは、問題が無いブロックのみを自身のチェーンに反映する)

## バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする



# まとめ
- トランザクションのライフサイクルを詳細に確認した　

詳細は構造はここまで。最後にEthereumのガバナンスと課題をみてみよう。