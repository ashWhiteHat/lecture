- [The Merge](#the-merge)
- [トランザクションのライフサイクル](#トランザクションのライフサイクル)
  - [トランザクションの伝搬](#トランザクションの伝搬)
    - [Ethereumネットワークのノードについて](#ethereumネットワークのノードについて)
    - [Ethereumネットワークへの参加について](#ethereumネットワークへの参加について)
  - [独立したトランザクションの検証](#独立したトランザクションの検証)
    - [Intrinsic gasについて](#intrinsic-gasについて)
  - [EthereumのMempool](#ethereumのmempool)
  - [ブロックの提案・投票ノードの選択](#ブロックの提案投票ノードの選択)
    - [PoWからPoSへ](#powからposへ)
    - [Stakingとバリデータ、バリデータノード](#stakingとバリデータバリデータノード)
    - [ランダムな選択](#ランダムな選択)
    - [ランダムな選択 (提案ノード)](#ランダムな選択-提案ノード)
    - [ランダムな選択 (投票ノード)](#ランダムな選択-投票ノード)
  - [ブロックへの投票 (attestation)](#ブロックへの投票-attestation)
  - [ブロックの作成](#ブロックの作成)
    - [Etherreumブロックのデータ構造](#etherreumブロックのデータ構造)
    - [ブロックヘッダの新要素](#ブロックヘッダの新要素)
    - [Uncle Blockについて](#uncle-blockについて)
    - [Block Gas Limitについて](#block-gas-limitについて)
    - [baseFeePerGasの決定ルールについて](#basefeepergasの決定ルールについて)
    - [State Root, Receipts Rootについて](#state-root-receipts-rootについて)
  - [トランザクションの実行](#トランザクションの実行)
  - [ブロックチェーンの構造](#ブロックチェーンの構造)
  - [EthereumのPoW (Proof-of-Work)](#ethereumのpow-proof-of-work)
    - [block intervalと難易度調整について](#block-intervalと難易度調整について)
  - [独立したブロックの検証](#独立したブロックの検証)
  - [コンセンサスとマイニング報酬](#コンセンサスとマイニング報酬)
    - [GHOSTプロトコルについて](#ghostプロトコルについて)
    - [EthererumのGHOSTプロトコルについて](#ethererumのghostプロトコルについて)
    - [Ethererumのマイニング報酬について](#ethererumのマイニング報酬について)
- [まとめ](#まとめ)


# The Merge

- スケーラビリティ問題への対処を主目的に、Ethereumは2022年の8月に互換性の無い形での大規模な仕様変更がおこなわれた （The Merge）
  - PoWからPoSへ (i.e., マイニングの廃止)
  - マイナーノード → バリデータノード
- これによりコンセンサスと報酬の仕組みが根本的に変わった
  - 伴わせてブロックのデータ構造も変化

![The-Merge](./img/the-merge.png)

[https://ethreum.org/roadmap/merge](https://ethreum.org/roadmap/merge) から引用


# トランザクションのライフサイクル
 
The Merge後のEthereumの構成要素がどのように動くのか、トランザクションのライフサイクルを軸に詳細を確認します。

PoWの場合と比較して、以下の部分が異なっています。

``` diff
EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する
各ノードは、受け取ったトランザクションを独立に検証する
各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する
- マイナーノードは、溜まりから任意のトランザクションをブロックに格納する
+ バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる
+ 投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する
+ 提案ノードは、任意のトランザクションおよび宣言をブロックに格納する
- マイナーノードは、ブロック内のトランザクションを実行する
+ 提案ノードは、ブロック内のトランザクションを実行する
- マイナーノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ
+ 提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ
- マイナーノードは、PoW (Proof-of-Work) を経てブロックを完成させる
- マイナーノードは、完成したブロックを各ノードに伝搬する
+ 提案ノードは、完成したブロックを各ノードに伝搬する
+ 各ノードは、受け取ったブロックに問題が無いかを独立に検証する
各ノードは、受け取ったブロックに問題が無いかを独立に検証する
各ノードは、問題が無いブロックのみを自身のチェーンに反映する
Ethereumは、最も重いチェーンを「正しい」状態遷移の記録とする
```

1. EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する
2. 各ノードは、受け取ったトランザクションを独立に検証する
3. 各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する
4. バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる
5. 投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する
6. 提案ノードは、任意のトランザクションおよび宣言をブロックに格納する
7. 提案ノードは、ブロック内のトランザクションを実行する
8. 提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ
9. 提案ノードは、完成したブロックを各ノードに伝搬する
10. 各ノードは、受け取ったブロックに問題が無いかを独立に検証する
11. 各ノードは、問題が無いブロックのみを自身のチェーンに反映する
12. バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする


## ブロックの提案・投票ノードの選択

### PoWからPoSへ

詳しくは後述しますが、スケーラビリティ問題に対応するため、Ethereumは2022年8月にブロック作成要件をPoWからPoSへ移行しました.これによって、Bitcoinと仕様が大きく異なり始めます。

EthereumのPoSは、おおまかには次の仕組みでブロック作成者を決定します。

まず、full (またはarchive) nodeは、自身が管理するEOAからdeposit contractと呼ばれるコントラクトアカウントに32ETH以上を預ける (stakeする) ことでバリデータノードになれます。

将来のブロック作成者はバリデータノードの中から定期的に選択されますが、このとき以前のブロックに投票するバリデータノードたちも選択されます。ここでの選択は確率的に行われますが、選択される確率は各バリデータノードのstake量で重み付けされています。

この仕組みによって、PoWのように、各ノードが`採掘作業を重複して行う必要`がなくなります。そのためネットワークを維持するためのエネルギー消費が抑えられて効率的でエコになります。

しかし、"PoW vs PoS" はブロックチェーンにおいて最も伝統的な論点の1つであり、現在も様々な観点 (e.g., どちらが公正なのか？ どちらが効率的なのか？ どちらが分散的なのか？ どちらが環境に優しいのか？) で研究・分析が引き続き行われています。


### Stakingとバリデータ、バリデータノード 

EOAは32ETHをdeposit contractに預けることで、アカウント用の鍵とは別にValidator Signing KeyとWithdrawal Keyの2種類 (それぞれ秘密・公開鍵から成る) が得られます。

この様にValidator用の鍵を別途用意するのは、次の3つの理由によります。
1. セキュリティ上、アカウント用の鍵とバリデータ用の鍵は分けておきたい
2. SaaS(Staking as a Service)などを運用する余地を残しておきたい(詳細後述)
3. 楕円曲線暗号よりも署名の集約に適した暗号形式を用いたい

2種類の鍵は、トランザクションを作成することは出来ません。一つのEOAが複数のバリデータ用の鍵を持つことも出来ます。この32ETH毎に作られる2種類の鍵を持つ単位を、ここでは便宜上「バリデータ」と呼び「バリデータノード」とは区別するものとします。

> 2024年1月において、バリデータの数は約900,000個

バリデータ用の鍵を別途作ることにより、次のような運用が可能になります。

1. 自身が管理するバリデータ鍵をノードに渡すことで、Stakingを委任出来る。この場合、自身でノードを建てずともStakingが行える (Staking as a Service; SaaS)
2. また、そもそもバリデータ自体を自分で用意せずにStakingを行うことも出来る。つまり、Bitcoinにおけるマイニングプールのように少額のETHを集約して共用のバリデータ (Staking Pool)を運用することが可能です。

Solo Staking, SaaS, Staking Poolの3つの運用方法について、それぞれの特徴を以下にまとめます。
  
|  | 自身で用意するもの | 自身で作成するもの | 自身で管理するもの | トラストへの依存 |
| ---- | ---- | ---- | ---- | ---- |
| Solo Staking | full (or archive) node, 32ETH以上のETH | バリデーターノード, バリデーター | バリデーターノード, バリデーター | 低
| Staking as a Service (SaaS) | 32ETH以上のETH | バリデーター |  | 中
| Staking Pool | 任意量のETH | |  | 高
  

### ランダムな選択

Ethereumのブロックチェーンは、12秒をslot、32slot (6.4分) をepochと呼び、slot, epoch単位でブロックの提案や合意形成、報酬などを管理しています。Bitcoinではslotは (block intervalとして) 約10分になるように設計されていました。Bitcoinにおけるdifficultyの概念はEthereumには存在しません。

### 提案ノードの選択

提案ノードの選択は、1つ前のepochのslot 0 時点で一気に行われます。このとき、バリデータのstake量が多いほど選ばれる確率が高くなりますが、32ETHを超えるともう上がらないようになっています。また、詳細は後述しますが、stakeされたETHはペナルティとして一部が没収される可能性があります。したがってバリデータのstake量は (事後的に) 32ETH未満になりえます。

多くのバリデータを管理するノードほど、ブロック提案の権利を得る確率が高まるため、ノードの視点からすれば32ETHが宝くじ1枚のような扱いになっています。


### 投票ノードの選択

提案ノードと同様に、epochの各slotに対応するブロック投票者も、1つ前のepochのslot 0 時点で一気に選択されます。1slotにnバリデータ (not バリデータノード) ずつ割り当てられます。このバリデータたちはcommiteeという単位でまとめられ、合意形成に必要な投票を担います。なぜなら、投票の集約はcommitee単位で並列化して行った方が効率的だからです。1slotあたりのcommitee数と1commiteeあたりのバリデータ数は、ネットワーク上の総バリデータ数に応じてepoch毎に変動します。最近のnは15,000~20,000あたりです。したがって1epochの間に全バリデータに投票機会があります。

同様に、多くのバリデータを管理するノードほど、ブロック投票の権利を得る確率が高まるため、ノードの視点からすれば32ETHが宝くじ1枚のような扱いになっています。

## ブロックへの投票 (attestation)

Commiteeに選ばれたバリデータ (実際にはそれを管理するノード) は、ブロックチェーンの構造に関する投票 (attestation) を行うことが出来ます。

- 割り当てられたslotのブロックは未作成なので、それ以前の内容に関して投票を行います
- ただし投票自体は、32slot先までの間ならば一応行えます 
- 具体的には次の二つを宣言します
  1. 現在どのブロックが先端にあるか？
  2. 現在どのブロックが最新のepochの最初のブロックか？の2つを宣言します

宣言の中身は以下のとおり

| 名称 | 役割 |
| ---- | ---- |
| slot | 割り当てられたslotの番号
| index | そのslotにおける何番目のcommiteeに所属しているか
| beacon_block_root | 先端だと思うブロックのヘッダーのハッシュ
| source | 最新のjustified (後述) されたと思うブロック
| target | 現在のepochで最初にあると思うブロック

上記がcommiteeごとに集約され同じslotのブロック提案者に渡されます。このとき、slot, indexが同じでも、残り3つの情報が異なる場合は別のグループに集約されます。投票が遅れた場合には、投票時のslotのブロック提案者に渡されます。

この集約の際には Validator Signing Key が使用されます。EOAの鍵 (楕円曲線暗号)とは異なる形式 (BLS署名) のため、署名の集約を行うことが出来ます。

## ブロックの作成

### Ethereumブロックのデータ構造

バリデーターノードは、Mempool (MempoolのうちPending pool) に溜まったトランザクションから、任意のトランザクションを選択してブロックに格納します。このとき、gasLimitとgasPriceがトランザクションを選ぶ際の参考になります。普通は計算量に対して得られる手数料が高そうなトランザクションを選択します。

トランザクションは、マークル・パトリシアツリー構造でブロックに格納されます。ここまでは基本的にBitcoinと同じです。しかし、Ethereumにおけるブロックの作成作業はこれだけに留まりません。Ethereumのブロックは、Bitcoinのそれ以上に様々な情報を格納しているのです。

### ブロックヘッダの新要素

| 名称 | 役割 |
| ---- | ---- |
| shaUncles | Uncleブロックのブロックヘッダリストをハッシュ化したもの
| extraData | 任意のデータ (32byteまで)
| gasLimit | ブロック全体のgasLimit
| gasUsed | ブロックに格納された全トランザクションのgasUsedの合計
| logsBloom | ブロック内の全トランザクションの実行ログ (Bloom Filter形式)
| miner | ブロックを作成したノードが持つ、報酬受取用のアドレス
| mixHash | nonce と合わさることでPoWのための十分な計算がされたことの証明になる256bitのハッシュ
| number | ブロックの番号 (genesis blockを0として累積)
| totalDifficulty | このブロック以前のブロックのdifficultyの総和
| State Root | このブロックの全トランザクションが実行された後の、全てのアカウント状態をマークルパトリシアツリーで要約したRoot値のハッシュ値(KECCAK-256ハッシュ形式)
| Receipts Root | このブロックの全レシートをマークルパトリシアツリーで要約したRoot値のハッシュ値(KECCAK-256ハッシュ形式)

### Uncle Blockについて

バリデーターノードは、トランザクションに加えてUncle blockの情報もブロックに格納します。Uncle blockとは、メインチェーンから分岐したブロックのことです。各ブロックに任意のUncle blockのブロックヘッダを2つまで格納することが出来ます。Ethereumは、Block intervalがBitcointと比較するとより頻繁に分岐するため、Uncle blockを考慮した合意形成 (GHOST protocol) を採用し、かつUncle blockにも報酬を与えています。

### Block Gas Limitについて

Ethereumのブロックには、ブロックサイズの上限が設定されていません（Bitcoinは4MB）。その代わりに、block用のgasLimitが設定されており、ブロックに格納された全トランザクションのgasLimitの合計がこのblock gasLimitを超えてはならないことになっています。
（ここで、Block gasLimitとTransaction gasLimitはしばしば混同されるので注意してください。前者はバリデーターノードが決める変数で、後者はEOAが決める変数です）

Ethereumにおいて、バリデーターノードはトランザクションの実行も担うため、彼らの負担は容量よりも計算量で把握した方が適切です。このような「スマートコントラクト用のプラットフォームとして計算量(gas)を軸に物事を考えよう」という思想はEthereumのブロックチェーンにおいて一貫しています。

バリデーターノードは、Block gasLimitを30,000,000Gweiまで増やすことが出来ます。ただしこれから説明する仕組みのとおり、ターゲット値は15,000,000Gweiとなっています。

### baseFeePerGasの決定ルールについて

baseFeePerGasはブロック毎に固定で、以下のルールに沿って内生的に決まります。

1つ前のブロックのBlock gasLimitが最大値(30,000,000Gwei)の何％であるかによって、baseFeePerGasの増減割合が決まります。

- 0%の場合 → -12.5%
- 0〜50%の場合 → -12.5〜±0%
- 50%の場合 → ±0%
- 50〜100%の場合 → ±0〜 +12.5 %
- 100%の場合 → +12.5% 


つまり：Txが増える → バリデーターノードがBlock gasLimitを増やす → 次のbaseFeePerGasが増加する → EOAが高い手数料を忌避してTxを作らなくなる → 混雑の緩和に繋がる(and vice versa)という流れが想定されています。直感的に言えば、手数料に難易度調整のような仕組みを導入していると言えます。これは、EOAにfeePerGasを決めさせるよりも、支払う手数料を最適化できそうであるため

### State Root, Receipts Rootについて

Ethereumでは、トランザクションを実行した結果として、状態とレシートをマークルパトリシアツリー状にしたRootもブロックに格納することになっています。トランザクションとは違い、ブロックに格納されるのはRoot部分のみです。

EOAとCAが保持する状態データと、Message CallトランザクションとContract Creationのレシートは、全ての歴史をarchive nodeが保持していることを思い出してください。

- Ethereumでは、トランザクションを実行した結果として、状態とレシートをマークルパトリシアツリー状にしたRootもブロックに格納する 
- ただしトランザクションとは違い、ブロックに格納されるのはRoot部分のみ!
- 復習: EOAとCAが保持する状態データ
- 復習: Message CallトランザクションとContract Creationのレシート
- 状態ツリーとレシートツリーの全歴史は、archive nodeが保持している

<!-- 芝野さん授業スライドの図を挿入 -->

改めて整理すると、状態(state)に関して各ノードが保持するデータは以下の通り:

- Light node
  - Transaction root, state root, receipt root (block header)
- Full node
  - Transaction root, state root, receipt root (block header)
  - Transaction data (block)
  - State data (latest 120 blocks)
  - Receipt data (latest 120 blocks)
- Archive node
  - Transaction root, state root, receipt root (block header)
  - Transaction data (block)
  - State data
  - Receipt data

つまりスマートコントラクト用に書かれたプログラムの実行結果は、archive nodeも持っていない!
- ハッシュ化したものだけをstorage rootとして保持している。
- (プログラムのコード自体はエンコード化されたものがcontract creation トランザクションのinputに入っている)
- 「あるEOAの過去の残高」などの情報は、ブロックチェーン内のトランザクションデータを計算することでfull
nodeでも把握することは出来る。ただしarchive nodeが持つ状態データを参照した方が早い。

## トランザクションの実行
バリデーターノードは、各トランザションに対して以下の処理を行う:
1. 状態ツリーにあるトランザクション作成者(EOA)のnonceを1増やす
2. 実行に必要であろうether (gasLimit * feePerGas + value) を作成者 (EOA) の残高から徴収
3. inputにある処理を (EVMを用いて) 実行
   1. もし結局Gasが足りなければ、out of gas exceptionエラーとして処理を中断
4. 実行結果に関するレシートを発行
5. 処理にかかったGas feeのうち、priority fee部分 (priorityFeePerGas * gasUsed) を自身のアドレスへ送金
   1. もしGasが余ったならば、その分は作成者(EOA)に返金


バリデーターノードは、ブロックに対して以下の処理を行う:
1. 状態ツリーとレシートツリーを作成する
   1. Full nodeの場合、120ブロック経過したらlocal storageから削除
2. ブロックヘッダーにState rootとReceipt rootを書き込む
3. ブロックヘッダーにgasUsedを書き込む

## ブロックチェーンの構造
ここはBitcoinと同じ。親のブロックヘッダのハッシュを自身のブロックヘッダに格納することでチェーンを形成する

## EthereumのPoW (Proof-of-Work)
- 現在のEthereumはBitcoinと同様にPoWを採用している
  - 現在はProof-of-Stake型へと以降している
  - `なぜ?: ブロック作成にかかる時間を短縮し、処理速度の向上を図りたいから (後述)`
- ただしEtherumのPoWは、オリジナルのEthashというアルゴリズムを採用している
  - `なぜ?: バリデーターノードの寡占化を可能な限り防ぎたいから`
  - 当時Bitcoinのマイニングは、それ専用の演算マシンであるASICが開発されたためにマイナーの寡占化が進んでいた
  - この現状を鑑みて、Ethereumは演算を繰り返す形ではなく、メモリからデータを繰り返し呼び出して比較する形でnonceを探すPoWを実装した (ASIC-resistantなどと呼ばれる)
- Ethashの詳細については時間の都合上説明を割愛するが、以下の資料が非常にわかりや
すい
  - 【第5回】Ethereumの全体像を理解する - MiningとConsensus
  - https://www.etarou.work/posts/4983481

### block intervalと難易度調整について
- Ethereumのblock intervalは、Bitcoinの10分に対して、15秒に設定されている
  - `なぜ?:スマートコントラクト用プラットフォームとして、処理速度の向上を図りたいから`
  - 送金ならば10分待てるかも知れないが、プログラムの実行はそんなに待てない
- ただし先述のとおり、block intervalが短いとその分チェーンが分岐しやすくなる
- Ethereumの難易度調整は、 Bitcoinは2016ブロック毎だったが、1ブロック毎に行われる
  - `なぜ?:より安定的に規定のblock intervalを維持したいため`
  - 難易度調整の仕様はメジャーアップデートの度にコロコロ変更されているが、現在は
    - Parent blockのdifficultyとtimestamp
    - Uncle blockのdifficultyとtimestampを元に計算されている。
  - 昔はuncle blockは用いられていなかった
- 計算方法の詳細については時間の都合上説明を割愛するが、以下の資料が非常にわかり
やすい
  - Ethereumのディフィカルティに関するまとめ
    - https://blockchain.gunosy.io/entry/ethereum-difficulty-summary - Ethereumのディ
フィカルティ算出方法

## 独立したブロックの検証
- 各ノードは、受け取ったブロックについて以下の内容を検証する
- 検証内容は基本的にビットコインと同様 (だがUTXOとアカウントベースという設計の違いが存在)
- トランザクションと同様、検証に通ったブロックのみを隣接ノードへと転送する
  - ブロックのデータ構造が正しいか
  - ブロックヘッダに含まれるtimestampが、ノードが持つ時間より+2時間以内に収まっているか
  - ブロックヘッダに含まれているdifficultyが正しいか
  - ブロックヘッダに含まれるnonceがdifficultyの条件を満たしているか (PoWの検証)
  - Transaction gasLimitの合計 ≦ Block gasLimitになっているか
  - 適切なUncle blockを格納しているか
  - ブロックに含まれるすべてのトランザクションが 「独立したトランザクション検証」のチェックリストをすべて満たすか
  - ブロックに含まれるすべてのトランザクションを実行した結果である、State ｒoot, Receipts root, gasUsed, logsBloomが正しいか

謝罪: ブロックの検証はBitcoinと同様に全てのfull (or archive) nodeが行うのか？それともバリデーターノードだけが行うのか？ギリギリまで調べていたのですが、結局わかりませんでした。申し訳ありません。
*トランザクションの検証はlight node含む全てのノードが行っています。


## コンセンサスとマイニング報酬
### GHOSTプロトコルについて
- Ethereumでは、Bitcoinとは異なり「最も長いチェーン」を正統な記録とする (Nakamoto
consensus) わけではない!
- 代わりに「最も重いチェーン」を正統とする
- これはGHOST (Greedy Heaviest Observed Subtree) プロトコルと呼ばれる
  - *元々はBitcoinに対する改善提案でした
- チェーン選択のアルゴリズムは比較的単純で、小ブロックのサブツリー数を比較し続けるだけ
  - 特に頻繁に分岐するブロックチェーンでは、このように「長さより重さ」で選択すべきではないか?
- 頻繁に分岐するブロックチェーンにおいては、攻撃に必要なコストもより高くなる
  - 以下の例では、攻撃者がメインチェーンとなるためには、さらに6ブロックがAチェーンに必要
  - *言い換えれば、合意形成においてUncle (or Orphan) blocksにも意味を持たせることが出来る

### EthererumのGHOSTプロトコルについて
Ethereumでは、このようなGHOSTプロトコルに以下の変更を加えている
- サブツリー数の比較は、現在のメインチェーンの先端から7つ前にあるブロックから始める
  - `なぜ?: Genesisブロックから始めると計算が大変だから`
- メインチェーンの先端のブロックが2つ以上になった場合、ブロックが含むUncle block (のブロックヘッダ) に記載されたdifficultyの合計が大きい方を先端のブロックとする

### Ethererumのマイニング報酬について
Ethereumでは、ブロックの作成に成功したバリデーターノードへ2ETHが新規発行される
- Bitcoinと異なり半減期はない
- Bitcoinと異なりblock maturityの設定 (100 confirmations) もない

さらに、もしブロックがuncle blockのブロックヘッダを含んでいる場合...
- 2ETHの報酬が3.125%増える (Uncle inclusion rewards)
  - `なぜ?:バリデーターノードに、uncle blockの格納を促したいから`
- Uncle blockを作成した各ノードに対して、2ETHの87.5%分の報酬が新規発行される
- Uncle blockの子ブロック (nephew block) を作成した各ノードに対して、 2ETHの3.125%分の報酬が新規発行される
  - `なぜ?: 頻繁にブロックチェーンが分岐する環境でもマイニングへの参入を促したいから`
  - ただし対象となるUncle blockは (EthereumのGHOSTプロトコルが扱う範囲である) 現在のメインチェーンの先端から7つ前以内のブロックから分岐している必要がある

*この仕様が本当に上手く機能するものなのか?特に、block maturityの設定が存在せずとも良い
のか?については、個人的に疑問を持っています。

# まとめ
- トランザクションのライフサイクルを詳細に確認した　

詳細は構造はここまで。最後にEthereumのガバナンスと課題をみてみよう。