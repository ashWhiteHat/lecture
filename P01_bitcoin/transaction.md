- [トランザクションとは何か](#トランザクションとは何か)
  - [従来の中央集権型取引との違い](#従来の中央集権型取引との違い)
- [トランザクションの登場人物](#トランザクションの登場人物)
  - [1. ブロックチェーン（ハッシュチェーン）](#1-ブロックチェーンハッシュチェーン)
    - [ハッシュについて](#ハッシュについて)
  - [2. P2P（Peer to Peer）](#2-p2ppeer-to-peer)
  - [3. ノード](#3-ノード)
    - [\*Merkle tree について](#merkle-treeについて)
  - [4. マイニング](#4-マイニング)
  - [5. PoW（Proof of Work）](#5-powproof-of-work)
    - [PoW の目的](#powの目的)
    - [PoW の流れ](#powの流れ)
    - [PoW の課題](#powの課題)
- [トランザクションのライフサイクル](#トランザクションのライフサイクル)
  - [トランザクションの検証について](#トランザクションの検証について)
  - [Orphan transaction（オーファントランザクション）について](#orphan-transactionオーファントランザクションについて)
- [トランザクションのモデル](#トランザクションのモデル)
  - [UTXO モデル](#utxoモデル)
  - [アカウントモデル](#アカウントモデル)
  - [比較](#比較)
  - [UTXO の保管について](#utxoの保管について)
- [UTXO の構造](#utxoの構造)
  - [locktime（nLockTime）について](#locktimenlocktimeについて)
    - [トランザクション単位のタイムロック](#トランザクション単位のタイムロック)
    - [UTXO 単位のタイムロック](#utxo単位のタイムロック)
  - [vin の構造](#vinの構造)
  - [vout の構造](#voutの構造)
- [トランザクション手数料](#トランザクション手数料)
- [Bitcoin Script](#bitcoin-script)
  - [特徴](#特徴)
  - [Bitcoin Script における処理の具体例](#bitcoin-scriptにおける処理の具体例)
- [トランザクションの種類](#トランザクションの種類)
  - [Pay-to-Public-Key-Hash (P2PKH)](#pay-to-public-key-hash-p2pkh)
  - [Pay-to-Public-Key](#pay-to-public-key)
  - [Multi-Signature](#multi-signature)
  - [データアウトプット（OP_RETURN）](#データアウトプットop_return)
  - [Pay-to-Script-Hash (P2SH)](#pay-to-script-hash-p2sh)
- [Coinbase トランザクション](#coinbaseトランザクション)
  - [Coinbase トランザクションの vin について](#coinbaseトランザクションのvinについて)
  - [Coinbase トランザクションの承認について](#coinbaseトランザクションの承認について)
- [\*SegWit（Segregate Witness）](#segwitsegregate-witness)
  - [SegWit の導入理由について](#segwitの導入理由について)
  - [ブロックウェイト（Block Weight）](#ブロックウェイトblock-weight)
  - [ブロックサイズについて](#ブロックサイズについて)
  - [トランザクション方式について](#トランザクション方式について)
- [まとめ](#まとめ)

# トランザクションとは何か

- **トランザクション** とは、**暗号資産所有者が使用権利を他の人に渡す、すなわち送金すること**

```
Bitcoin(暗号資産)は分散型コミュニティによって管理される。
Bitcoinを所有したり、その権利を譲渡するためにはコミュニティ全体の承認を受ける必要がある。
そのため、利用者はトランザクションと呼ばれるデータをコミュニティに検証・承認してもらう。
この過程において、取引が正常に行われているかを確認する。
```

## 従来の中央集権型取引との違い

```
従来(Web2)における取引では、中央管理者が通貨の偽造や二重支払などの詳細をチェックしていたが、
Bitcoin(Web3)においてはすべてがプログラムで処理されるようになった。（PoWの恩恵、後述）
これによって取引の透明性やセキュリティ面が担保されるようになった。
```

# トランザクションの登場人物

- トランザクションを理解するにあたって必要な知識を最初にまとめた
- 特にトランザクションと切り離せない内容であるマイニングについてはよく理解してほしい

## 1. ブロックチェーン（ハッシュチェーン）

- **ブロックチェーン** とは、**トランザクション情報をまとめた「ブロック」をハッシュポインタに従ってつないだもの**

  - ハッシュポインタによってすべてが連結されているため、１つのブロックを改ざんするためには他の過半数も改ざんする必要がある
  - これによって実質的に改ざん不可能の性質を獲得している

- Bitcoin におけるブロックは以下の要素で構成される

  | 項目                       | 役割                                                                                         |
  | -------------------------- | -------------------------------------------------------------------------------------------- |
  | ブロックヘッダー（Header） | ブロックの整合性を保つための情報やマイニングに使われる情報、トランザクションの要約を提示する |
  | ブロック本体（Body）       | トランザクションのデータを保持する                                                           |
  | ブロックのサイズ           | ブロックの容量を示す                                                                         |
  | トランザクションの個数     | トランザクションの数を示す                                                                   |

- \*特にブロックヘッダーは以下の構成になっている

  | 項目                 | 役割                                                                           |
  | -------------------- | ------------------------------------------------------------------------------ |
  | ハッシュポインタ     | 直前のブロックのハッシュを示しチェーン状を保つ（連結されていることを担保する） |
  | ナンス （Nonce）     | マイニングの際に利用される１度だけ使われる数（使い捨ての数）                   |
  | Merkle tree          | Merkle tree の根ノード（トランザクション内容の要約だと理解してよい）           |
  | バージョン           | プロトコルのバージョン番号                                                     |
  | タイムスタンプ       | ブロックのおおよその作成時間（UNIX 形式）                                      |
  | 難易度（Difficulty） | マイニング時に使用される難易度                                                 |

  `注：Merkle treeについてはノードの項目を参照のこと。`

- 2024 年現在では Bitcoin の１ブロックは１ MB が上限となっている

  - 初期では最大 36MB の取引を含めることができていたが、2010 年に縮小された
  - Bitcoin のブロック容量については様々な議論が起こっている
  - 近年では Bitcoin の利用者も増え、上限に達することも多いことから容量拡大を求める声もある（スケーラビリティ問題）
  - 一方でブロックサイズの拡大は、Full node の負担が大きくなったり、DoS などの攻撃リスクを上昇させる可能性もある
  - ここからハードフォークや「セグウィット（Segregated Witness：SegWit）」が始まった

- 現在 SegWit の採用率は上がっており、ブロックサイズは４ MB に拡大されたと解釈する人もいる
  - SegWit については[SegWit（Segregate Witness）](#segwitsegregate-witness)を参照のこと

---

### ハッシュについて

- Bitcoin におけるハッシュとは、暗号学的ハッシュ関数「SHA-256」によって生成される 256 ビットの値である
- 簡単に言うと、この関数は入力された値に対して、入力値が特定困難な値を返す

以下、ハッシュ関数を $H$ , 入力 $x$ に対する出力を $H(x)$ とする

```
例：
      H(1) = 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b があったときに、
      H(1) から x = 1 を推測するのは困難であるということである。
```

- またハッシュ関数の特徴として、同じ入力値には必ず同じ出力値をとる
- これにより、推測された値 $x$ が正しいかどうかを確認するためには $H$ に $x$ を入力するだけで簡単にわかる
- これらの性質によって、ブロックチェーンは改ざん困難かつ、第三者の検証（PoW）が可能になっている

#### \*暗号学的ハッシュ関数

- 暗号通貨に使用されるハッシュ関数は、数学的なハッシュ関数が満たす条件に加え以下の条件を満たすものである

1. ハッシュ値から入力値が特定困難であること（原像計算困難性）

   - これに関しては上述したとおりである

2. 同じハッシュ値を得るような入力値を見つけるのが困難であること（第 2 原像計算困難性）
   - すなわち、 $H(x) = H(y)$ かつ $x \neq y$ となるような組 $(x, y)$ を見つけるのが困難であるということである

- 「困難」というのは、理論上は可能だが実現性がとても低いという意味である

---

## 2. P2P（Peer to Peer）

- **P2P**とは、**サーバーなどの中心的な機関や装置を持たず、末端の端末（ピア）同士が互いに信頼し合うことで成立するネットワークのこと**
- Bitcoin では非構造化ネットワーク (Unstructured P2P Network) が利用されている

  - \*Bitcoin ではプロトコルとして Gossip や Diffusion を使用している

- 冗長性がありデータ処理を分散して素早く実行できる一方で、悪意あるユーザーを排除しにくい

## 3. ノード

- **ノード**とは、**Bitcoin ソフトウェアを実行するコンピューターのこと**
- ウォレットなどもノードに分類される
- Bitcoin におけるノードには以下の種類がある

  |                  | 検証の対象             | ストレージ要件              |
  | ---------------- | ---------------------- | --------------------------- |
  | Full node        | チェーン全体を検証     | 約 550GB 程度 (2024/2 時点) |
  | Miner node       | 複数のトランザクション | Full node と同じ            |
  | Light node (SPV) | ブロックヘッダーのみ   | Full node の 1 / 1000 程度  |

  `注：Full nodeのストレージ要件はブロック数が増えるごとに日々増加している。`

---

- ### Full node

  - チェーン全体の完全なコピーをホストし同期する（クライアントが独立してチェーンを検証できる）
  - マイナーが作成したブロックの検証を行う（２重支払いのチェックなど）
  - イメージとしては、ネットワークのセキュリティと整合性の維持を目的とすると考えて構わない
  - Light node（SPV node）に対して信頼されたチェーンを提供する
  - Light node（SPV node）と比べ、セキュリティやプライバシーの観点で優れている
  - Pruned node という Full node のストレージ要件を削減するためにできたノードも存在する（Bitcoin Core）
  - Pruned node は Light node（SPV node）にブロックを提供できない

- ### Miner node

  - ネットワーク上にブロードキャストされたトランザクションをマイニングを通じて検証する
  - Full node はブロックの検証を行う一方で、Miner node は新たなブロックを作成する
  - 運用に多大な計算・ストレージリソースを割く必要がある

  ```
  Full nodeとMiner nodeに関しては、ノードとして同一種類であるという見解も多々存在する。
  それらの見解は、どちらもネットワークを健全に維持するためのノードであるという理由からである。
  今回大別したのは、「マイナー」がどのような存在かをイメージしやすくするためである。
  ```

- ### Light node (SPV: Simplified Payment Verification)
  - ブロックヘッダーのコピーを基に、支払いを検証する
    - この際にボディやその他の情報は取得せず、ヘッダ列のみを取得する
    - ヘッダだけでもジェネシスブロックから検証ができるから
  - ウォレットやマルチビットで使用される
  - ノードに関係のある情報しか取得しないため軽量である一方で、閲覧できる情報に制限がある
  - Full node からデータを取得する際に、データ不整合が起こるリスクがある
  - \*ノードのハッシュをツリー化した、Merkle tree によって検証可能になっている

---

### \*Merkle tree について

- Merkle tree とは、多数のデータをハッシュ化して階層状にしたもの

  - ブロックチェーン発祥の技術ではなく、もとからあったものを Bitcoin のトランザクションで使用している
  - Bitcoin ではトランザクションをマークルツリーで管理し、ブロック内に含まれるトランザクション全体を要約する

- 各トランザクションのダブルハッシュを取り、隣のハッシュとつなげてまたダブルハッシュを取り、と繰り返していく

  - 最上位ノードを特に「Merkle root」と呼ぶ
  - Merkle root は常に 32 バイトになる
  - \*要素（葉ノード）が奇数個の時は、１番最後の要素が複製され使用される

    ![Merkle treeの構造](./img/merkletree.drawio.svg)

- どこか１つでも「葉」が書き換えられると、Merkle root の値が変化する

  - したがって、トランザクションが書き換えられていないかの確認に使用される（ブロックヘッダーに保持）

- また、ある「葉」が含まれるかの検証が効率よく行える
  - \*検証に必要な「葉」の数はブロック内のトランザクション数 $N$ について $log_2(N)$ 個
  - 上記図を例にとり、 $H_A$ が含まれるかを確認するとする
  - 必要な「葉」は $H_B$ と $H_{CD}$ のみである
  - なぜならば、それら２つがあれば $H_A$ と合わせて Merkle root を求められるからである
  - $H_B$ と $H_{CD}$ のように、検証に必要な「葉」を「Proof」と呼ぶ

---

## 4. マイニング

- **マイニング**とは、**トランザクションを検証・承認しブロックに情報を保存すること**
- マイニングが行われることによって Bitcoin が新規発行される（発行上限は 2100 万枚と決まっている）
- これを実行するノードは「マイナー（Miner）」と呼ばれ、マイニングの報酬として Bitcoin（暗号資産）を享受する

  - マイニングによって Bitcoin を受け取れるのは、最初に数学的問題を解いた者だけである
  - これによりマイナー同士の競争が起こる

- Bitcoin には半減期という仕組みがあり、マイニングによって得られるビットコインが半分に減少するタイミングがある

  - 半減期はおよそ４年に１回程度で起こっている（正確には 21 万ブロックごと）
  - マイニング報酬の遷移は以下の通り

    | 半減期の回数（実施年）        | マイニング報酬 |
    | ----------------------------- | -------------- |
    | 初期                          | 50BTC          |
    | 1 回目（2012 年）             | 25BTC          |
    | 2 回目（2016 年）             | 12.5BTC        |
    | 3 回目（2020 年）             | 6.25BTC        |
    | 4 回目（2024 年と予想される） | 3.125BTC       |

- マイニング作業は、コンセンサスアルゴリズムに PoW（Proof of Work）を採用しているブロックチェーンで行われる

  - 一方で、PoS（Proof of Stake）や DPoS（Delegated Proof of Stake）といったアルゴリズムを用いるチェーンでは「ステーキング（Staking）」が行われる
  - Bitcoin や Litecoin などが PoW を、Ethereum や Binance Coin などが PoS を採用している

- マイニングの具体的な流れについては次項（PoW の流れ）を参照のこと

## 5. PoW（Proof of Work）

### PoW の目的

- PoW の目的は、ノード同士が相互に信頼できない環境（P2P）において、すべてのノード間で合意、つまり相互に信頼を得ることにある
- 直接的に言うのであれば、あるノードのマイニング結果が本当に正しいものなのかを、ノード同士で確認しあうのである
- PoW による検証・承認を経て、新たなブロックが作成されチェーンに追加される

```
PoWは一定の計算量を投じたブロックのみOKとすると定めたルールであり、そのルールに合意するかどうかはビットコインに参加する個々人の判断に委ねられる。
結果的に残った人はそのルールを受け入れているため、コンセンサスが得られている。
```

### PoW の流れ

- PoW における作業は、計算リソースを必要とする複雑な数学的問題を解くことである

  - 多量の計算リソースを要求することによってブロックの改ざんを実質的に不可能にするため

- マイニング結果が、承認を行うノードに承認されるとブロックが新規追加される
- 具体的な流れは以下の通り

```
1. ノードがトランザクションを作成・送信する
2. 送信されたトランザクションはネットワークにブロードキャストされ、プール（待機所のようなもの）に入れられる
3. マイナーがプールから複数のトランザクションを選択し、新たなブロックを作成する
4. マイナーが数学的問題を解き（有効なナンスを求めて）、ブロックを提示する
5. 他のノードが、検証・承認を行った上で自身が持つブロックチェーンに追加する
6. ブロックが承認され、その中に含まれるトランザクションも承認される
```

- この PoW を含めた一連の流れを「マイニング」と呼んでいる

### PoW の課題

- #### 消費電力が多い

  - マイニングを行うためにはただでさえ多くの計算リソースを要求される
  - それに加えて、最初の 1 人以外は利益（Bitcoin）を得ることができないため競争が起こる
  - マイナーはより大規模なマシンを用意し、消費電力が増える
  - 2023 年の電力消費量は約 121.13TWh であった（https://ccaf.io/cbnsi/cbeci）
  - したがって環境負荷が懸念されている

- #### スケーラビリティ問題

  - Bitcoin では、約 10 分に１回新しいブロックが生成されるようになっている（「難易度（Difficulty）」によって自動調整される）
  - しかし需要がどんどん増える中で、10 分という時間がボトルネックになってきた
  - トランザクションを処理しきれず、「詰まり」が発生するようになった

- #### 51%攻撃
  - 上記にあったように、マイニング結果が承認を行うノードの 51%（過半数）に承認されれば新規ブロックを作成できる
  - したがって１つの組織（利用者）が 51%の承認を行えるようになると、虚偽のトランザクションを通すことができるようになる
  - このような脆弱性があるが、現状大量の承認ノードが存在するので過半数を占めるのは困難
  - Bitcoin 側も、マイニングの「難易度」を上げることで対策をしている

# トランザクションのライフサイクル

- トランザクションのライフサイクルは以下の通り（PoW の流れも参照のこと）

### 1. 組成

- 送金先のアドレスを指定する
- Bitcoin を送る人がデジタル署名を付与する

### 2. ブロードキャスト

- トランザクションをネットワークに送信
- 送信されたトランザクションは各ノードに送信される

### 3. マイニング

- マイナーによって各トランザクションが検証される
- 検証に成功した有効なトランザクションが、マイナーによって新規ブロックに含まれる
- マイナーが新たに作成したブロックを提示する

### 4. 記録

- マイナーから提出されたブロックを Full node が検証する
- 検証に成功したブロックは最も長いチェーンへと繋がれる（記録される）

## トランザクションの検証について

- トランザクションが検証される内容について、大まかには以下の通り

  1. 資金の不足がないか
  2. トランザクション形式は正しいか
  3. 二重支払ではないか
  4. オーファントランザクションが含まれていないか
  5. 署名は有効か
  6. 手数料は適切か

- この他にも、ネットワークの混雑状況、トランザクションを送信するソフトウェアなどが原因で検証に失敗することもある

## Orphan transaction（オーファントランザクション）について

- Orphan transaction とは、親子関係が逆転してしまったトランザクションのことである

  - トランザクションは必ずしも送信順に検証されるわけではない（ネットワーク間の伝達スピードの関係）
  - そのため、送金の順番が前後した状態でノードに届いてしまうことがある
  - この場合、トランザクションは「オーファントランザクションプール」に入れられ、親を待機する
  - 親が届くと、親を待機していたすべてのトランザクションが取り出される

- オーファントランザクションプールには上限（MAX_ORPHAN_TRANSACTIONS）がある

  - これはノードからの DOS 攻撃を防ぐため
  - これを超えた場合、ランダムなトランザクションが破棄される

- 説明は省くが、オーファントランザクションと似たものに「Orphan block（オーファンブロック）」もある

# トランザクションのモデル

- トランザクションの構造は Bitcoin などが使用する UTXO モデルと、Ethereum などが使用するアカウントモデルに大別される

```
注：以降、「インプット」「アウトプット」という単語が出てくるが、それぞれ「出金元」「送金先（または自身の口座）」
    というような理解で一旦読み進めて構わない。正確には「UTXOの構造」で登場する、「vin」「vout」に該当する。
```

- ## UTXO モデル
- **UTXO（unspent transaction output）** とは、**トランザクションアウトプットのうちまだ使用されていないもの**
- UTXO モデルにおける残高は、未使用のビットコインの固まりである

  - イメージとしては、普段使うお札のようにある程度の金額が固まっている状態である
  - したがって、UTXO モデルにおいて暗号資産を使用する場合は「おつり」が返ってくることがある（後述する）
  - また、普段複数のお札を使って支払いができるように、UTXO においても複数のアウトプットを使って支払いができる（後述する）
  - どのアウトプットから使われるかはウォレットによる

- １度使用された UTXO は２度と使用することができない

  - これによって２重支払いを防いでいる
  - 「おつり」が発生する場合は、金額分の新たな UTXO が生成される

- 残高を求めるには UTXO のアウトプットを合計する必要がある

  - 誰がいくら持っているのかが分かりにくいため、プライバシーの観点では優れている
  - しかし一方で、残高を求めるためにその都度合計しないと求まらないという観点では扱いずらい

- ## アカウントモデル

  - 銀行口座のように、アカウントの残高を直接データとして記録する
  - したがって支払う際は、引き出し元の残高を減らし、送金先の残高を増やすだけ
  - 要するに銀行の振込と仕組みは同じ

- ## 比較

  |                    | UTXO モデル | アカウントモデル |
  | ------------------ | :---------: | :--------------: |
  | プライバシー       |      ○      |                  |
  | データサイズ       |             |        ○         |
  | 同時処理           |      ○      |                  |
  | シンプルさ         |             |        ○         |
  | 対リプレイアタック |      ○      |                  |

  `注：リプレイアタックの詳細は省略するが、簡単に言うと資金流出である。`

  - アカウントモデルには複雑なインプットが必要ないのでトランザクションデータが比較的小さい

    - UTXO は複数のトランザクションをインプットにとる可能性があるが、アカウントモデルでは出金元は１つだけ
    - その分ほかの情報を詰め込むことができる

  - UTXO は複数のアウトプットから通貨を集めて支払うため、同時処理が比較的しやすい

    - 支払いに使用するアウトプットがすべて独立していれば（すなわち単射であれば）、同時処理が可能
    - 逆にアカウントモデルでは、同時処理する取引において、アカウントが十分な資金を持っているか確認する必要がある

  - アカウントモデルの方がシンプルな処理を行うので、機械処理はアカウントモデルの方が向いている

    - スマートコントラクトでアカウントモデルの方が利用されている一因である

  - また、UTXO はリプレイアタックのリスクが低い
    - UTXO が区別されれば同一に残高を計算できないから
    - Ethereum では「The DAO 事件」が起きた

## UTXO の保管について

- UTXO モデルではアカウントモデルと異なり各アドレスの残高をチェーンで管理しない

  - そのため UTXO は Full node の DB で管理される
  - この特別な DB は「UTXO セット」と呼ばれる

- UTXO セットは新たなブロックが作成されるごとに更新されブロードキャストされる

  - ウォレットなどのノードはその情報をもとに残高を算出する
  - また、暗号資産の総流通量もこれを基に算出される

- UTXO のデータ構造は、Bitcoin のパフォーマンスとストレージ要件に直接影響を及ぼす
  - なぜならば、これらのデータはオンチェーンでの処理と切り離せないからである
  - したがって、UTXO セットのデータ構造を最適化することが重要視される

# UTXO の構造

- UTXO モデルは以下の要素で構成される
- ちなみに「tx」は「transaction」の略である

  | 名称                  | 説明                                                           | 役割                                                        |
  | --------------------- | -------------------------------------------------------------- | ----------------------------------------------------------- |
  | txid                  | トランザクションの一意の識別子（ウィットネスデータなし）       | どのトランザクションから UTXO を作成したかを保持する        |
  | \*hash                | ウィットネスデータを含めたトランザクションのハッシュ値         | SegWit においてトランザクションの完全性を保証する           |
  | size                  | トランザクションのデータの大きさ                               | ブロックを１ MB に収めるためにマイナーが参照するための値    |
  | \*vsize               | SegWit の重みを低くしたときの仮想サイズ                        | SegWit 導入時のデータサイズを公平に計算するための値         |
  | \*weight              | $nonWitnessDataSize*4+WitnessDataSize$で表せるブロックウェイト | SegWit 導入時のアウトプットに係るコストを最適化するための値 |
  | version               | トランザクションのタイプを指定する整数値                       | 適用されるフォーマットやルールセットの互換性を保つための値  |
  | locktime（nLockTime） | UNIX タイムスタンプまたはブロック高                            | アウトプットをいつから使用可能にするかを指定するための値    |
  | vin                   | 入力されるトランザクションの配列                               | どのトランザクションどの出力を支払いに使うのかを指定する    |
  | vout                  | 出力されるトランザクションの配列                               | アドレスやスクリプトを指定し、新たに出力を作成する          |

  `補足：txidはデータをダブルハッシュ（SHA256を2回）した値をバイトオーダー逆順にしたもの。`

  `注：使用するデコーダーによっては、名称、構造や要素の数が提示しているものとは異なる場合がある。`

- 実際のデータはこのようになっている（デコード済み）
- 見やすさのために、要素の並び替えや省略（vin の asm, hex の部分）を行った

```json
{
  "txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
  "hash": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
  "size": 258,
  "vsize": 258,
  "weight": 1032,
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig": {
        "asm": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c",
        "hex": "483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c6f191"
      },
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.015,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG",
        "desc": "addr(1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA)#ykrtxd0a",
        "hex": "76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac",
        "address": "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA",
        "type": "pubkeyhash"
      }
    },
    {
      "value": 0.0845,
      "n": 1,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
        "desc": "addr(1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK)#e6ft626y",
        "hex": "76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
        "address": "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK",
        "type": "pubkeyhash"
      }
    }
  ]
}
```

（「東京大学大学院工学系研究科技術経営戦略学専攻ブロックチェーンイノベーション寄付講座」より引用）

- 上記のトランザクションでは、以下のような操作をしている（ブロックエクスプローラーを見るとわかる）

  - 自分のアドレス`1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK`（残高 0.1BTC）から

    - 0.015BTC をアドレス`1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA`に送信
    - 0.0845 をアドレス`1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK`に送信（自分に戻した）

  - 残りの 0.0005BTC はトランザクション手数料になった
  - タイムロックは付与しない
  - トランザクション方式は P2PKH

## locktime（nLockTime）について

- 「アウトプットをいつから使用可能にするかを指定する」と説明したが、以下のような指定方法がある

  |                      | 相対時間                     | 絶対時間                       |
  | -------------------- | ---------------------------- | ------------------------------ |
  | トランザクション単位 | nSequence                    | nLocktime                      |
  | UTXO 単位            | CSV（CHECK SEQUENCE VERIFY） | CLTV（Check Lock Time Verify） |

### トランザクション単位のタイムロック

- #### nSequence

  - もともとは locktime に達していないトランザクションを置換するための値だった

    - しかし、手数料によってはマイナーにインセンティブがなかった
    - そのためうまく機能しなかった
    - このほかにもサービスを妨害する脆弱性（割愛する）が見つかったため無視されるようになった
    - 現在デフォルトでは整数最大値である「0xFFFFFFFF（4294967295）」が設定されている

  - 元の用途で使用されなくなったので相対時間タイムロックとして再利用されることとなった（BIP-68 による）

    - \*これにより以下のように意味が再定義された

      | 名称         | 役割                                                           |
      | ------------ | -------------------------------------------------------------- |
      | Disable Flag | 相対時間タイムロックを使用するかのフラグ                       |
      | Type Flag    | 秒単位（512 秒単位）とブロック高単位のどちらを使用するかを指定 |
      | Value        | 時間のデータを示す                                             |

    - \*したがって nSequence $>$ 0xEFFFFFFFFF であればロック不使用を意味し、nSequence $\leqq$ 0xEFFFFFFF で使用を意味する
    - \*ロックを使用する場合、22 番目のビットが１であれば、秒単位の使用を意味する
    - \*時間データは最初の 16 ビットから解釈される
    - \*512 秒なのは Bitcoin の Block time が 10 分（600 秒）に設定されているためである

    ![nSequenceの各ビットにおける役割](./img/encoding.png)

    (https://github.com/bitcoin/bips/blob/master/bip-0068/encoding.png)

  - 時間指定のインプットが複数ある場合、例えば２つの場合、それぞれの条件 $A, B$ について $A \cap B$ を満たすと有効になる（積集合）

- #### nLockTime

  - トランザクションは指定時間までマイニングされない（ネットワークに伝搬されず，トランザクションプールにも入らない）

    - これによって、アウトプットは指定された時間まで使用できない
    - しかし、アウトプット（送金する資金）の資金源となる、インプットの使用は制限されていない
    - したがってロックが解除されたときには、トランザクションが無意味になっている（送金する通貨がすでに使用済みになった）可能性がある

  - この問題を解決するために生まれたのが CLTV である
  - \*また、nLockTime は値の範囲で意味が異なる

    | 範囲                          | 意味                                                  |
    | ----------------------------- | ----------------------------------------------------- |
    | $nLockTime = 0$               | タイムロックなし                                      |
    | $0 < nLockTime < 500,000,000$ | そのトランザクションが有効になるブロック高            |
    | $500,000,000 < nLockTime$     | そのトランザクションが有効になる Unix Epoch Timestamp |

### UTXO 単位のタイムロック

- #### CSV

  - マイニングされブロックに取り込まれた時間に対して、特定のブロック数または秒数が経過するまで UTXO の使用が制限される
  - ライトニングネットワークなどのオフチェーン技術で用いられている

- #### CLTV

  - UTXO に対する相対時間タイムロックを実現する

    - 2015 年に Bitcoin Script に加えられた
    - 資金をタイムロックの時点まで使用不可能にし、nLockTime での問題を解決した

  - \*以下のようなロッキングスクリプトになる

    - 例えば、アリスがボブにお金を支払う例。3 か月後に有効になるロッキングスクリプトとなっている

      `<now + 3 months> CHECKLOCKTIMEVERIFY DROP DUP HASH160 <Bob's Public Key Hash> EQUALVERIFY CHECKSIG`

      （「東京大学大学院工学系研究科技術経営戦略学専攻ブロックチェーンイノベーション寄付講座」より引用）

    - <now + 3months>は nLockTime と同じく 5 億を閾値とする
    - この UTXO を Input とするトランザクションを作成するときは以下に留意する

      - アンロックスクリプトにはボブの署名と公開鍵を入れる
      - トランザクション内の nLockTime を 3 か月後以降にする

        ```
        設定されているnLocktimeが<now+3month>より小さかったら実行は停止（無効とされる）、大きかったら続行される。
        そもそも現在時刻が指定されているnLocktimeより大きい場合は、そのトランザクションは無効となり伝搬されない。
        ```

## vin の構造

- 資金の引き出し元を示す配列が vin である

  - 複数の UTXO を持つこともある

- vin は以下の要素で構成される

  - \*txinwitness は SegWit 使用時のみ含まれる項目である

  | 名称                          | 説明                                         | 役割                                                                      |
  | ----------------------------- | -------------------------------------------- | ------------------------------------------------------------------------- |
  | txid                          | インプットに入れられる UTXO を暗号化したもの | 使用する vout を保有するトランザクションを示す                            |
  | vout                          | 使用する UTXO のインデックス                 | txid で指定したトランザクションにある vout のうち、どの UTXO かを指定する |
  | scriptSig（Unlocking Script） | トランザクションのロックを解除するための情報 | アウトプットの所有権を証明する                                            |
  | sequence（nSequence）         | 現在は相対ロックタイムを示す                 | 前項[nSequence](#nsequence)を参照のこと                                   |
  | \*txinwitness（Witness Data） | インプットごとの証人データを格納した配列     | SegWit 導入時に署名データなどを保持する                                   |

### scriptSig（Unlocking Script）について

- scriptSig は、vout にある scriptPubKey によるロックを解除するための情報が入っている

  - トランザクションの形式によって、scriptSig の中身は変わる
  - 詳細は各トランザクション形式の説明を参照のこと

- 「asm」にアセンブリ形式で、<署名><公開鍵> の並びで入っている（Bitcoin Script）

  - 「hex」はそれの 16 進数形式のもの
  - 以下は上に掲載したトランザクションの、vin の asm データ

    `3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf`

- 正しい Unlocking Script 作成には秘密鍵が必要である
  - 不正な Unlocking Script のトランザクションは、当然だがノード到達時に検証に失敗する

## vout の構造

- 資金の送信先を示す配列が vout である

  - vout はそれぞれが新しく作成される UTXO である
  - 「おつり」などの余剰分の手数料もいずれかの UTXO に含まれる

- vout は以下の要素で構成される

  | 名称                           | 説明                                         | 役割                                                     |
  | ------------------------------ | -------------------------------------------- | -------------------------------------------------------- |
  | value                          | アドレスに送られる Bitcoin の量              | 単位は「Satoshi」である（ $1Satoshi ＝ 0.00000001BTC$ ） |
  | n                              | UTXO のインデックス                          | vin で UTXO を指定する際に使用するインデックス           |
  | scriptPubKey（Locking Script） | トランザクションのロックを解除するための情報 | アウトプットの所有権を証明する                           |

### scriptPubKey（Locking Script）について

- scriptPubKey は、vout を使用できる人を制限するための条件を指定している

  - トランザクションの形式によって、scriptPubKey の中身は変わる
  - 詳細は各トランザクション形式の説明を参照のこと

- 構成要素はおおよそ以下の通り（以下と異なる可能性もある）

  | 名称    | 説明                                       | 役割                                             |
  | ------- | ------------------------------------------ | ------------------------------------------------ |
  | asm     | トランザクションのロック解除条件スクリプト | 通貨の持ち主だけが使用できるようにロックをかける |
  | hex     | asm の 16 進数表記版                       | 受信側が検証の際に使用する                       |
  | address | 送金先アドレス                             | 送金先を指定する                                 |
  | type    | トランザクションの種類                     | ロックにかかわる形式を指定                       |
  | \*desc  | 出力記述子                                 | ウォレットやアドレス形式をサポートする           |

  - type では P2PK や P2SH といった形式を指定する（トランザクションの種類は後述する）
  - \*desc は様々な種類の記述しをサポートしている（今回は addr）
    - \*詳しくは (https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md) を参照のこと

`補足：scriptSigとscriptPubKeyは鍵と南京錠のような、対の関係であることを理解してほしい。`

# トランザクション手数料

- **トランザクション手数料**とは、**トランザクションをマイニングするマイナーに対するインセンティブのこと**

  - したがってマイナー達は基本的に、手数料が多いものからブロックに取り込む
  - 逆に手数料が低すぎるものに関しては、プールから削除する

- 手数料にはスパム防止の意味合いもある
- 適切な手数料はトランザクションのデータサイズによって左右される

  - Bitcoin では記述量が手数料を決定する（Ethereum では計算量）
  - したがって、vin や vout に記述される量は少ないほうが、手数料は安くなる
  - 上記のことに留意してトランザクションを作成しよう

- マイナーに渡される手数料は以下の式で算出される

  $TransactionFee = Sum(vin) - Sum(vout)$

- また手数料は指定することもできる

  - 優先して処理したいトランザクションであれば、手数料を増加させれば優先的にマイニングされる
  - 逆に手数料がデータサイズに対して不適切（過少）であると、ずっとマイニングされない可能性もある
  - 基本的には、ウォレットが自動的に手数料を計算して支払っている

- したがって、手数料は市場原理のように決定される
- ノードによっては、すでに送信したトランザクションの手数料をあとから変更することもできる
  - \*前述の「nSequence」（BIP68）や、オプトイン RBF（BIP125）などがある

# Bitcoin Script

- Unlocking / Locking Script に使用される言語のこと

`注：以降「pop」「push」といった単語が出てくるが、それぞれ「１番最後に入れたものを取り出す」「スタックに要素を追加する」という意味である。`

## 特徴

### 1. スタックベースの処理

- データ、オペコードは LIFO（後入れ先出し）でスタックされる

  - \*スタック上のバイトベクトルの長さの上限は 520 バイト

- 左から右へ処理する
- 故にシンプル

### 2. チューリング不完全

- 簡単に言うと、特定の役割に特化しているということ

  - Bitcoin Script は Unlocking / Locking Script に特化している

- またチューリング不完全だと、ループ、再帰、自身で強制終了しない他の goto 変数をサポートしない
  - これが任意の実行を走らせにくくしている

### 3. オペコードを使用する

- 「OP_ADD」や「OP_EQUAL」のような、処理を指示する文字列をオペコードという
  - \*整数や論理値をスタックから取り出すオペコードは 4 バイト以下

### 4. ステートレス

- これにより、どんなシステム上でも同じプロセスで実行できる
  - この結果の予測可能性は Bitcoin システムの本質的な利点である

## Bitcoin Script における処理の具体例

- 以下のコードが与えられたときの処理を考える

  `2 3 OP_ADD 5 OP_EQUAL`

- オペコードの役割は次の通り

  | 名称     | 役割                                                                                                                          |
  | -------- | ----------------------------------------------------------------------------------------------------------------------------- |
  | OP_ADD   | スタックから 2 つのデータを pop して、それらを加算した結果をスタックに push する                                              |
  | OP_EQUAL | スタックから 2 つのデータを pop して、それらが等しければ True(数値の 1)、等しくなければ False(数値の 0)をスタックに push する |

- 実際の処理手順

  | 処理                                               | 結果               |
  | -------------------------------------------------- | ------------------ |
  | 1. OP_ADD に従って、左から２つデータを取り、足す   | 　`5 5 OP_EQUAL`   |
  | 2. OP_EQUAL に従って、左から２つデータを取り比べる | $5 = 5$            |
  | 3. 等しいので整数の１を入れる                      | `1`                |
  | 4. オペコードがないので終了                        | 実行結果は**True** |

- 参考画像

  ![Bitcoin scriptの処理プロセス](./img/process.png)
  (https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch05.html)

- Unlocking / Locking Script もこの要領で処理される
  - 実行結果が True 以外だった場合は、UTXO には何の変化も与えられない

# トランザクションの種類

- 以下が 5 つの標準的なトランザクションである
  - これら以外にもあるので注意してほしい

| 名称                           | 説明                                   |
| ------------------------------ | -------------------------------------- |
| Pay-to-Public-Key-Hash (P2PKH) | 標準的な送金トランザクション           |
| Pay-to-Public-Key              | 昔使用されていたトランザクション       |
| Multi-Signature                | 複数人の署名が必要なトランザクション   |
| データアウトプット(OP_RETURN)  | 支払いとは関係ないトランザクション用   |
| Pay-to-Script-Hash (P2SH)      | より複雑な処理が可能なトランザクション |

## Pay-to-Public-Key-Hash (P2PKH)

- P2PKH は Bitcoin アドレスに支払う場合に使われる
- 現在では P2PKH が一般的な送金処理において使用されている

- ### 使用されているオペコードの役割

  | 名称        | 役割                                                                   |
  | ----------- | ---------------------------------------------------------------------- |
  | OP_DUP      | スタックの１番上要素を複製してスタックに push する                     |
  | OP_HASH160  | SHA256 と RIPEMD160 を通す関数（HASH160 関数）のこと（ダブルハッシュ） |
  | OP_CHECKSIG | デジタル署名が公開鍵とマッチするかを確かめる                           |

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `OP_DUP OP_HASH160 <送金先アドレスの公開鍵ハッシュ> OP_EQUAL OP_CHECKSIG`

    - `<送金先アドレスの公開鍵ハッシュ>`はアドレスを Base58 でデコードした値

  - Unlocking Script

    `<送金先アドレスに対応する署名> <送金先アドレスの公開鍵> `

  - つなぎあわせた以下の Script が True になれば OK

    `<Unlocking Script> <Unlocking Script>`

  - やっていることは次の２つ
    - インプットにある公開鍵がアウトプットのものと同じかどうかがチェック
    - その公開鍵で署名の検証が可能か、すなわち秘密鍵をもっているかをチェック

## Pay-to-Public-Key

- 主に coinbase トランザクションで使用される
- P2PKH よりシンプルな送金形式で、公開鍵ハッシュではなく公開鍵そのものを使用する

  - 通常の送金時に使用する場合，送金先アドレスの公開鍵も必要になる

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `<送金先アドレスの公開鍵> OP_CHECKSIG`

  - Unlocking Script

    `<送金先アドレスに対応するデジタル署名> `

  - つなぎあわせた以下の Script が True になれば OK

    `<Unlocking Script> <Unlocking Script>`

## Multi-Signature

- ロッキングスクリプトにいくつかの公開鍵を登録しておき，そのうちのいくつかの署名をアンロッキングスクリプトで必要とするトランザクション
  - 複数の署名がないと送金できないようにしたい場合に使用する（供用する場合など）
- Bitcoin だけの概念ではなく、一般に「M-of-N スキーマ」として知られているものである
  - $N$ 個の公開鍵のうち、少なくとも $M$ 個の対応する署名が必要（ $M \leqq N$ ）
  - 例えばよく使われる 2-of-3 マルチシグネチャの場合は、3 個の公開鍵のうち 2 つの署名が必要
- マルチシグネチャ script では最大 15 個の公開鍵が使用可能

  - しかし`Support up to x-of-3 multisig txns as standard`と書かれている

    （https://github.com/bitcoin/bitcoin/blob/master/src/policy/policy.cpp#L80）

  - P2SH にラップされたマルチシグネチャスクリプトにおいて 15 個使用できる模様

- ### 使用されているオペコードの役割

  | 名称             | 役割                                                                       |
  | ---------------- | -------------------------------------------------------------------------- |
  | OP_CHECKMULTISIG | 設定された N 個の公開鍵に対応するデジタル署名が M 個揃っているかを検証する |
  | OP_0             | 空のバイト配列をスタックに push する                                       |

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `M <公開鍵 1> <公開鍵 2> ... <公開鍵 N> N OP_CHECKMULTISIG`

    - `M`、`N`は M-of-N の数字

  - Unlocking Script

    `OP_0 <デジタル署名1> <デジタル署名2> …`

    - `OP_CHECKMULTISIG`は実行した時に、処理に関係のないスタック上の要素を余分に 1 つ pop してしまうバグがある
    - そのため余分な`OP_0`を入れておく
    - この`OP_0`は`OP_CHECKMULTISIG`に無視される

  - つなぎあわせた以下の Script が True になれば OK

    `<Unlocking Script> <Unlocking Script>`

## データアウトプット（OP_RETURN）

- 支払いには関係がないトランザクションを作成する場合に使用する

  - トランザクションはブロックチェーンによって改ざん不可能なデータになる
  - これはデータの存在証明(Proof of Existence)に使用することができたりと応用が効く
  - そのような情報を作成するためにこのトランザクションが利用される

- 使用不可ということが明示的アウトプットを作り出す

  - そのため対応する Unlocking Script は存在しない

- ### 使用されているオペコードの役割

  | 名称      | 役割                                   |
  | --------- | -------------------------------------- |
  | OP_RETURN | トランザクションを無効としてマークする |

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `OP_RETURN <data> `

    - `<data>`は 80 バイト

  - Unlocking Script

    - 存在しない

  - 検証は常に失敗する

#### このトランザクション形式の存在理由について

- このトランザクションは UTXO の DB を削減するために作成された

  - UTXO は使用されると DB から削除されるようになっている
  - しかし検証に常に失敗する UTXO は使用されず、溜まる一方
  - そこで妥協的解決案として、このトランザクションが生まれた

- このトランザクションで作成される UTXO は、UTXO の DB に保存されない
  - そのために、`OP_RETURN`という明示的なアウトプットを作成する

## Pay-to-Script-Hash (P2SH)

- 複雑な script を単純化できるようにしたもの
  - 複雑なスクリプトを使用するのは現実的に難しい（後述の例を参照）
- スクリプトそのものの代わりにそのスクリプトのハッシュ値をロッキングスクリプトに用いる

  - そのスクリプトをリディーム（引き換え）スクリプト（Redeem script）と呼ぶ
  - これにより，長いスクリプトはアンロッキングスクリプト内に含まれることになる

- ### P2SH の使用例

  #### 状況

  - 2-of-5 マルチシグでの P2SH の利用を考える

    ```
    とある会社では会社のアドレスからの送金に，社長と役員3人，弁護士の計5人のうちの2人の署名が必要としている。
    顧客からの支払い先にこのアドレスを使っている
    ```

    （「東京大学大学院工学系研究科技術経営戦略学専攻ブロックチェーンイノベーション寄付講座」より引用）

  #### P2SH を使用する理由

  - マルチシグをそのまま利用すると以下の問題がある

    - 支払い前にスクリプトの共有が必要
    - 公開鍵を複数含むためスクリプトサイズが大きい
    - UTXO プールを圧迫したり、手数料が増加したりする

  - P2SH はこのような問題を解決できる
    - 送金側で必要な手続きが減る
    - 長いスクリプトはアンロック側（資金を受け取る側）になるため、送信者に高額な手数料がかからない

  #### Script

  - Redeem Script

    ```
    2 <自分の Public Key> <パートナー1の Public Key> <パートナー2の Public Key> <パートナー3の Public Key> <弁護士の Public Key> 5 CHECKMULTISIG
    ```

  - Locking Script

    `OP_HASH160 <20-byte hash of Redeem Script> OP_EQUAL`

    - `<20-byte hash of Redeem Script>`は Redeem Script を、HASH160（Double hash）に通したもの

  - Unlocking Script

    `<Sig1> <Sig2> <Redeem script>`

  #### 実行

  - 通常の Bitcoin Script の実行手順と少し異なる

    1. `<Redeem Script> <Locking Script>`が`True`かを確認する
    2. `<Unlocking Script> <Redeem Script>`が実行される
    3. 2.の Script が True になれば OK

  - アンロック処理の実行の前に、署名対象（アンロック対象）が適切か（意図したものか）どうかを確認している

### P2SH の利点

- トランザクションのデータサイズを小さくすることができる

  - 手数料の削減
  - UTXO サイズの削減

- Script はアドレスとして実装されるので、ウォレットは P2SH に関する複雑な実装の必要がない

  - 取引の簡略化

- 長いスクリプトのトランザクション手数料は、受け取り側が支払うようにできる

  - 受け取り側は払う側に負担を強いる必要がなくなる

- 複雑な送金処理ができる
- P2SH アドレスとして通常の Bitcoin アドレスと全く同じように使用することができる
  - \*P2SH を Base58 encode して使用する
  - \*Version Prefix には「５」を使用し、アドレスは「３」から始まる

### P2SH の注意点

- 設計上、再帰処理ができない

  - すなわち、P2SH Redeem Script の中に P2SH を置くことはできない

- Redeem Script の中で`OP_RETURN`を使用することはできない

  - すなわち、OP_RETURN トランザクションは使用不可

- 正しくない Redeem Script を作成すると、使用できない UTXO が生まれる
  - Redeem Script はアンロックされて実行されるまで検証されない（ハッシュ化されているため）
  - したがってエラーも出ないし、UTXO の使用もできないといった事態が発生しうる

# Coinbase トランザクション

- **Coinbase トランザクション**とは、**マイナーへの報酬を支払うためのトランザクションのこと**

  - 誰かから資金を移動するのではなく、新しく Bitcoin を生成するトランザクション
  - したがって、vin に UTXO は含まれない

- vout には複数のアドレスを指定可能

  - 要するに通常のトランザクションと同じ構造
  - しかし後述するように、vin だけ少し特殊になっている

- このトランザクションは、ブロックに１つだけ存在する

  - ほとんどの場合トランザクションの１番最初に位置する

- このトランザクションのアウトプット総額は以下のように決まる

  - ブロック内の各トランザクションの手数料の合計
  - ブロック高に対する半減期を考慮したマイニング報酬
  - 式にすると以下のようになる

    $vout = Sum(transactionFees) + halvingRelative$

## Coinbase トランザクションの vin について

- UTXO をインプットにとらないため、以下の項目は一定である

  | 名称      | 値               |
  | --------- | ---------------- |
  | txid      | 32 バイトの null |
  | index     | 0xffffffff       |
  | nSequence | 0xffffffff       |

- 新たに Bitcoin を生成する性質上、Unlocking Script が不要

  - したがってマイナーは、Coinbase トランザクションの Script には任意のデータを入れることができる
  - これは「Coinbase Script」と呼ばれている
  - 使用可能なデータサイズは 2 ~ 100bytes
  - \*一般的にマイナーは、マイニング プールを識別する追加のナンス値と文字列を置く

- \*また BIP34 に従って、「version」が 2 のブロックではブロックの高さを含める必要がある

- 創設者の「Satoshi Nakamoto」も「Coinbase Script」で遊んでいる（有名なので紹介する）
  - `The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.`
  - 意味は不明（マイニング開始の日付を残すためだとか）

## Coinbase トランザクションの承認について

- Coinbase トランザクションは、少なくとも 100 回の確認を受ける（100 ブロック後）まで使用できない

- Bitcoin は新規ブロックを最長のチェーンにつなぐというルールがある

  - これは、最長のチェーンは最も労力（PoW）をかけて検証された、最も信頼できるものであるということから
  - これにより、ブロック生成で競合が起こってもチェーンが分裂するのを防いでいる

- 100 ブロック後という制約は、上記の仕組みにおいてチェーンの混乱（競合）を避けるための策である

# \*SegWit（Segregate Witness）

- **SegWit**とは、**署名データをトランザクションデータから分離したトランザクション方式のこと**

  - SegWit は 2017 年にソフトフォークとして実装された
  - とても分かりにくいと思うのだが、**ブロックサイズの上限を変更しているわけではない**

    ```
    ブロックサイズの上限自体を変更する（コードを書き換える）と後方互換性を保てないため、ハードフォークするしかない。
    しかしハードフォークは利用者にとっても開発者にとっても、望ましいことではない。
    そこでブロックサイズの上限は変えないが、実際にはデータが１MBを超えても互換性を保てる仕組みとして登場したのがSigWitである。
    そのため、従来のブロックサイズ上限１MBもサポートしている。
    どのような形で互換性を保っているのかに注目すると、SigWitのイメージがつかめるだろう。
    ```

  - ちなみにハードフォークである「SegWit2x」も存在する（ブロックのサイズが 2MB に変更）

- SegWit に対応していないノードでは Witness Data が無視される
  - 検証に通らない（署名がない）ため、トランザクションは失敗する

## SegWit の導入理由について

- SegWit は以下の問題を解決するために導入された
  - #### トランザクションデータの削減（効率化）
  - #### 取引速度の向上
  - #### トランザクション展性（Malleability）の克服

---

### トランザクションデータの削減（効率化）

- 前述したように、Bitcoin のブロックサイズは１ MB という制約がある

  - 署名データは最大でトランザクションデータのおよそ 65%ほどを占める
  - そこで Unlocking Script のデータを「Witness Data」に移すことによって、実質的なトランザクションデータの拡張を実現している

- これによって得た実質的な上限は４ MB である

- 1 つのブロックにより多くのトランザクションを含めることができるようになった

### 取引速度の向上

- １つのブロックにより多くのトランザクションが含まれることで、１秒間に処理できる件数（TPS）も多くなる
- これにより、ネットワークの混雑が緩和され手数料も安くなる

### トランザクション展性（Malleability）の克服

- トランザクション展性（Malleability）とは、トランザクション ID の改ざん容易性のこと

  - もう少し直感的に言うなら、トランザクションの意味を失わないようにしたまま、txid を変更すること
  - これにより２重支払いが引き起こされる可能性がある

- txid は Unlocking Script を含めたトランザクションデータをハッシュの対象にする

  - アンロックに無害なスクリプトを追加すれば、txid だけ変わる（`OP_NOP`など何もしないオペコードを追加するなど）
  - 同じトランザクション内容なのに txid だけ変わると、不一致が起こる（作成したトランザクションが見つからないなど）

- したがって、Unlocking Script がトランザクションデータの中にあるのは脆弱であるといえる

- SegWit は Unlocking Script を「Witness Data」に移動することで、この脆弱性に対応した

  - txid の作成において Witness Data は無視されるから

- この改善によって「ライトニングネットワーク」が誕生した
  - オフチェーンでのシステムを安全に展開できるようになった

---

## ブロックウェイト（Block Weight）

- 以下の式で定義される値を「ブロックウェイト」という

  $BlockWeight = nonWitnessDataSize*3 + TotalDataSize \iff nonWitnessDataSize*4 + WitnessDataSize$

  - $nonWitnessDataSize$ は Witness Data を除いたブロックサイズ（単位は MB）
  - $TotalDataSize$ は Witness Data も含めた全体のブロックサイズ（単位は MB）

    - すなわち、 $TotalDataSize = nonWitnessDataSize + WitnessDataSize$
    - ブロックサイズの上限は変わっていないため、 $0 < TotalDataSize \leqq 1MB$

  - $BlockWeight$ の単位は「Weight Unit（WU）」（上記式では MWU）である
  - また、 $0 < BlockWeight \leqq 4,000,000WU$ である

- **SegWit 対応ノードではブロックウェイトが、ブロックサイズに代わる制限となる**
  - すなわち、ブロックサイズが１ MB 以内という制限ではなく、**ブロックウェイトが 4,000,000WU 以内という制限に置き換わる**

## ブロックサイズについて

### 非 SegWit トランザクションの場合

- Witness Data が存在しないため、 $TotalDataSize = nonWitnessDataSize + 0$ より $TotalDataSize = nonWitnessDataSize$
- また $TotalDataSize \leqq 1MB$ より、 $nonWitnessDataSize \leqq 1MB$
- したがって、 $BlockWeight = nonWitnessDataSize*3 + TotalDataSize \leqq 1*3 + 1 = 4$ （単位はそれぞれ MWU、MB）
- 以上より、ブロックウェイトが 4,000,000WU 以内という条件に必要十分である（この条件で後方互換性を保てる）

### SegWit トランザクションの場合

- $0 < BlockWeight \leqq 4,000,000WU$ 、 $0 \leqq nonWitnessDataSize$ 、 $0 < WitnessDataSize$ である

  - $0 = nonWitnessDataSize$ になることなどほぼないだろう（理論的には可能）

- この条件において、 $0 \leqq nonWitnessDataSize < 1$ 、 $0 < WitnessDataSize \leqq 4$ である（単位は MB）
  - この結果からも、データサイズが４ MB になることはないことがわかるだろう
  - 実際、1 ～ 2.2 MB の範囲であることが多いようだ

## トランザクション方式について

- P2PKH、P2WSH に対応するものとしてそれぞれ P2WPKH、P2WSH がある
- 長くなってしまうので省略するが、ScriptSig が空だったりという違いがある

# まとめ

- とても長くなってしまったが、最後に以下のことをしっかりと再確認してほしい

  - ### トランザクションは資金残高を管理するデータである
  - ### ブロックチェーンはそのデータを正確に記録するためのものである

- これらを実現するために様々な技術や概念が利用された
- そしてさらなる利便性のために、様々なトランザクションが生まれたのである

- また今回紹介した技術的な内容は全体の、ほんの一部に過ぎない

# Note for me

- About ECDSA
- UTXO set
